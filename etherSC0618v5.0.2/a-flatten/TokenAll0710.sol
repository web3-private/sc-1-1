

// // Sources flattened with hardhat v2.22.5 https://hardhat.org

// // SPDX-License-Identifier: MIT

// // File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
//  * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
//  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
//  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
//  *
//  * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
//  * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
//  * case an upgrade adds a module that needs to be initialized.
//  *
//  * For example:
//  *
//  * [.hljs-theme-light.nopadding]
//  * ```solidity
//  * contract MyToken is ERC20Upgradeable {
//  *     function initialize() initializer public {
//  *         __ERC20_init("MyToken", "MTK");
//  *     }
//  * }
//  *
//  * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
//  *     function initializeV2() reinitializer(2) public {
//  *         __ERC20Permit_init("MyToken");
//  *     }
//  * }
//  * ```
//  *
//  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
//  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
//  *
//  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
//  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
//  *
//  * [CAUTION]
//  * ====
//  * Avoid leaving a contract uninitialized.
//  *
//  * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
//  * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
//  * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
//  *
//  * [.hljs-theme-light.nopadding]
//  * ```
//  * /// @custom:oz-upgrades-unsafe-allow constructor
//  * constructor() {
//  *     _disableInitializers();
//  * }
//  * ```
//  * ====
//  */
// abstract contract Initializable {
//     /**
//      * @dev Storage of the initializable contract.
//      *
//      * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions
//      * when using with upgradeable contracts.
//      *
//      * @custom:storage-location erc7201:openzeppelin.storage.Initializable
//      */
//     struct InitializableStorage {
//         /**
//          * @dev Indicates that the contract has been initialized.
//          */
//         uint64 _initialized;
//         /**
//          * @dev Indicates that the contract is in the process of being initialized.
//          */
//         bool _initializing;
//     }

//     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))
//     bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;

//     /**
//      * @dev The contract is already initialized.
//      */
//     error InvalidInitialization();

//     /**
//      * @dev The contract is not initializing.
//      */
//     error NotInitializing();

//     /**
//      * @dev Triggered when the contract has been initialized or reinitialized.
//      */
//     event Initialized(uint64 version);

//     /**
//      * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
//      * `onlyInitializing` functions can be used to initialize parent contracts.
//      *
//      * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any
//      * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in
//      * production.
//      *
//      * Emits an {Initialized} event.
//      */
//     modifier initializer() {
//         // solhint-disable-next-line var-name-mixedcase
//         InitializableStorage storage $ = _getInitializableStorage();

//         // Cache values to avoid duplicated sloads
//         bool isTopLevelCall = !$._initializing;
//         uint64 initialized = $._initialized;

//         // Allowed calls:
//         // - initialSetup: the contract is not in the initializing state and no previous version was
//         //                 initialized
//         // - construction: the contract is initialized at version 1 (no reininitialization) and the
//         //                 current contract is just being deployed
//         bool initialSetup = initialized == 0 && isTopLevelCall;
//         bool construction = initialized == 1 && address(this).code.length == 0;

//         if (!initialSetup && !construction) {
//             revert InvalidInitialization();
//         }
//         $._initialized = 1;
//         if (isTopLevelCall) {
//             $._initializing = true;
//         }
//         _;
//         if (isTopLevelCall) {
//             $._initializing = false;
//             emit Initialized(1);
//         }
//     }

//     /**
//      * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
//      * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
//      * used to initialize parent contracts.
//      *
//      * A reinitializer may be used after the original initialization step. This is essential to configure modules that
//      * are added through upgrades and that require initialization.
//      *
//      * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
//      * cannot be nested. If one is invoked in the context of another, execution will revert.
//      *
//      * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
//      * a contract, executing them in the right order is up to the developer or operator.
//      *
//      * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.
//      *
//      * Emits an {Initialized} event.
//      */
//     modifier reinitializer(uint64 version) {
//         // solhint-disable-next-line var-name-mixedcase
//         InitializableStorage storage $ = _getInitializableStorage();

//         if ($._initializing || $._initialized >= version) {
//             revert InvalidInitialization();
//         }
//         $._initialized = version;
//         $._initializing = true;
//         _;
//         $._initializing = false;
//         emit Initialized(version);
//     }

//     /**
//      * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
//      * {initializer} and {reinitializer} modifiers, directly or indirectly.
//      */
//     modifier onlyInitializing() {
//         _checkInitializing();
//         _;
//     }

//     /**
//      * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.
//      */
//     function _checkInitializing() internal view virtual {
//         if (!_isInitializing()) {
//             revert NotInitializing();
//         }
//     }

//     /**
//      * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
//      * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
//      * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
//      * through proxies.
//      *
//      * Emits an {Initialized} event the first time it is successfully executed.
//      */
//     function _disableInitializers() internal virtual {
//         // solhint-disable-next-line var-name-mixedcase
//         InitializableStorage storage $ = _getInitializableStorage();

//         if ($._initializing) {
//             revert InvalidInitialization();
//         }
//         if ($._initialized != type(uint64).max) {
//             $._initialized = type(uint64).max;
//             emit Initialized(type(uint64).max);
//         }
//     }

//     /**
//      * @dev Returns the highest version that has been initialized. See {reinitializer}.
//      */
//     function _getInitializedVersion() internal view returns (uint64) {
//         return _getInitializableStorage()._initialized;
//     }

//     /**
//      * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
//      */
//     function _isInitializing() internal view returns (bool) {
//         return _getInitializableStorage()._initializing;
//     }

//     /**
//      * @dev Returns a pointer to the storage namespace.
//      */
//     // solhint-disable-next-line var-name-mixedcase
//     function _getInitializableStorage() private pure returns (InitializableStorage storage $) {
//         assembly {
//             $.slot := INITIALIZABLE_STORAGE
//         }
//     }
// }


// // File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Provides information about the current execution context, including the
//  * sender of the transaction and its data. While these are generally available
//  * via msg.sender and msg.data, they should not be accessed in such a direct
//  * manner, since when dealing with meta-transactions the account sending and
//  * paying for execution may not be the actual sender (as far as an application
//  * is concerned).
//  *
//  * This contract is only required for intermediate, library-like contracts.
//  */
// abstract contract ContextUpgradeable is Initializable {
//     function __Context_init() internal onlyInitializing {
//     }

//     function __Context_init_unchained() internal onlyInitializing {
//     }
//     function _msgSender() internal view virtual returns (address) {
//         return msg.sender;
//     }

//     function _msgData() internal view virtual returns (bytes calldata) {
//         return msg.data;
//     }

//     function _contextSuffixLength() internal view virtual returns (uint256) {
//         return 0;
//     }
// }


// // File @openzeppelin/contracts/utils/introspection/IERC165.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Interface of the ERC165 standard, as defined in the
//  * https://eips.ethereum.org/EIPS/eip-165[EIP].
//  *
//  * Implementers can declare support of contract interfaces, which can then be
//  * queried by others ({ERC165Checker}).
//  *
//  * For an implementation, see {ERC165}.
//  */
// interface IERC165 {
//     /**
//      * @dev Returns true if this contract implements the interface defined by
//      * `interfaceId`. See the corresponding
//      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
//      * to learn more about how these ids are created.
//      *
//      * This function call must use less than 30 000 gas.
//      */
//     function supportsInterface(bytes4 interfaceId) external view returns (bool);
// }


// // File @openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)

// pragma solidity ^0.8.20;


// /**
//  * @dev Implementation of the {IERC165} interface.
//  *
//  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
//  * for the additional interface id that will be supported. For example:
//  *
//  * ```solidity
//  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
//  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
//  * }
//  * ```
//  */
// abstract contract ERC165Upgradeable is Initializable, IERC165 {
//     function __ERC165_init() internal onlyInitializing {
//     }

//     function __ERC165_init_unchained() internal onlyInitializing {
//     }
//     /**
//      * @dev See {IERC165-supportsInterface}.
//      */
//     function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
//         return interfaceId == type(IERC165).interfaceId;
//     }
// }


// // File @openzeppelin/contracts/access/IAccessControl.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev External interface of AccessControl declared to support ERC165 detection.
//  */
// interface IAccessControl {
//     /**
//      * @dev The `account` is missing a role.
//      */
//     error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);

//     /**
//      * @dev The caller of a function is not the expected one.
//      *
//      * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
//      */
//     error AccessControlBadConfirmation();

//     /**
//      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
//      *
//      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
//      * {RoleAdminChanged} not being emitted signaling this.
//      */
//     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

//     /**
//      * @dev Emitted when `account` is granted `role`.
//      *
//      * `sender` is the account that originated the contract call, an admin role
//      * bearer except when using {AccessControl-_setupRole}.
//      */
//     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

//     /**
//      * @dev Emitted when `account` is revoked `role`.
//      *
//      * `sender` is the account that originated the contract call:
//      *   - if using `revokeRole`, it is the admin role bearer
//      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
//      */
//     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

//     /**
//      * @dev Returns `true` if `account` has been granted `role`.
//      */
//     function hasRole(bytes32 role, address account) external view returns (bool);

//     /**
//      * @dev Returns the admin role that controls `role`. See {grantRole} and
//      * {revokeRole}.
//      *
//      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
//      */
//     function getRoleAdmin(bytes32 role) external view returns (bytes32);

//     /**
//      * @dev Grants `role` to `account`.
//      *
//      * If `account` had not been already granted `role`, emits a {RoleGranted}
//      * event.
//      *
//      * Requirements:
//      *
//      * - the caller must have ``role``'s admin role.
//      */
//     function grantRole(bytes32 role, address account) external;

//     /**
//      * @dev Revokes `role` from `account`.
//      *
//      * If `account` had been granted `role`, emits a {RoleRevoked} event.
//      *
//      * Requirements:
//      *
//      * - the caller must have ``role``'s admin role.
//      */
//     function revokeRole(bytes32 role, address account) external;

//     /**
//      * @dev Revokes `role` from the calling account.
//      *
//      * Roles are often managed via {grantRole} and {revokeRole}: this function's
//      * purpose is to provide a mechanism for accounts to lose their privileges
//      * if they are compromised (such as when a trusted device is misplaced).
//      *
//      * If the calling account had been granted `role`, emits a {RoleRevoked}
//      * event.
//      *
//      * Requirements:
//      *
//      * - the caller must be `callerConfirmation`.
//      */
//     function renounceRole(bytes32 role, address callerConfirmation) external;
// }


// // File @openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)

// pragma solidity ^0.8.20;




// /**
//  * @dev Contract module that allows children to implement role-based access
//  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
//  * members except through off-chain means by accessing the contract event logs. Some
//  * applications may benefit from on-chain enumerability, for those cases see
//  * {AccessControlEnumerable}.
//  *
//  * Roles are referred to by their `bytes32` identifier. These should be exposed
//  * in the external API and be unique. The best way to achieve this is by
//  * using `public constant` hash digests:
//  *
//  * ```solidity
//  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
//  * ```
//  *
//  * Roles can be used to represent a set of permissions. To restrict access to a
//  * function call, use {hasRole}:
//  *
//  * ```solidity
//  * function foo() public {
//  *     require(hasRole(MY_ROLE, msg.sender));
//  *     ...
//  * }
//  * ```
//  *
//  * Roles can be granted and revoked dynamically via the {grantRole} and
//  * {revokeRole} functions. Each role has an associated admin role, and only
//  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
//  *
//  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
//  * that only accounts with this role will be able to grant or revoke other
//  * roles. More complex role relationships can be created by using
//  * {_setRoleAdmin}.
//  *
//  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
//  * grant and revoke this role. Extra precautions should be taken to secure
//  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
//  * to enforce additional security measures for this role.
//  */
// abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {
//     struct RoleData {
//         mapping(address account => bool) hasRole;
//         bytes32 adminRole;
//     }

//     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;


//     /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl
//     struct AccessControlStorage {
//         mapping(bytes32 role => RoleData) _roles;
//     }

//     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))
//     bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;

//     function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {
//         assembly {
//             $.slot := AccessControlStorageLocation
//         }
//     }

//     /**
//      * @dev Modifier that checks that an account has a specific role. Reverts
//      * with an {AccessControlUnauthorizedAccount} error including the required role.
//      */
//     modifier onlyRole(bytes32 role) {
//         _checkRole(role);
//         _;
//     }

//     function __AccessControl_init() internal onlyInitializing {
//     }

//     function __AccessControl_init_unchained() internal onlyInitializing {
//     }
//     /**
//      * @dev See {IERC165-supportsInterface}.
//      */
//     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
//         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
//     }

//     /**
//      * @dev Returns `true` if `account` has been granted `role`.
//      */
//     function hasRole(bytes32 role, address account) public view virtual returns (bool) {
//         AccessControlStorage storage $ = _getAccessControlStorage();
//         return $._roles[role].hasRole[account];
//     }

//     /**
//      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
//      * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
//      */
//     function _checkRole(bytes32 role) internal view virtual {
//         _checkRole(role, _msgSender());
//     }

//     /**
//      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
//      * is missing `role`.
//      */
//     function _checkRole(bytes32 role, address account) internal view virtual {
//         if (!hasRole(role, account)) {
//             revert AccessControlUnauthorizedAccount(account, role);
//         }
//     }

//     /**
//      * @dev Returns the admin role that controls `role`. See {grantRole} and
//      * {revokeRole}.
//      *
//      * To change a role's admin, use {_setRoleAdmin}.
//      */
//     function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
//         AccessControlStorage storage $ = _getAccessControlStorage();
//         return $._roles[role].adminRole;
//     }

//     /**
//      * @dev Grants `role` to `account`.
//      *
//      * If `account` had not been already granted `role`, emits a {RoleGranted}
//      * event.
//      *
//      * Requirements:
//      *
//      * - the caller must have ``role``'s admin role.
//      *
//      * May emit a {RoleGranted} event.
//      */
//     function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
//         _grantRole(role, account);
//     }

//     /**
//      * @dev Revokes `role` from `account`.
//      *
//      * If `account` had been granted `role`, emits a {RoleRevoked} event.
//      *
//      * Requirements:
//      *
//      * - the caller must have ``role``'s admin role.
//      *
//      * May emit a {RoleRevoked} event.
//      */
//     function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
//         _revokeRole(role, account);
//     }

//     /**
//      * @dev Revokes `role` from the calling account.
//      *
//      * Roles are often managed via {grantRole} and {revokeRole}: this function's
//      * purpose is to provide a mechanism for accounts to lose their privileges
//      * if they are compromised (such as when a trusted device is misplaced).
//      *
//      * If the calling account had been revoked `role`, emits a {RoleRevoked}
//      * event.
//      *
//      * Requirements:
//      *
//      * - the caller must be `callerConfirmation`.
//      *
//      * May emit a {RoleRevoked} event.
//      */
//     function renounceRole(bytes32 role, address callerConfirmation) public virtual {
//         if (callerConfirmation != _msgSender()) {
//             revert AccessControlBadConfirmation();
//         }

//         _revokeRole(role, callerConfirmation);
//     }

//     /**
//      * @dev Sets `adminRole` as ``role``'s admin role.
//      *
//      * Emits a {RoleAdminChanged} event.
//      */
//     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
//         AccessControlStorage storage $ = _getAccessControlStorage();
//         bytes32 previousAdminRole = getRoleAdmin(role);
//         $._roles[role].adminRole = adminRole;
//         emit RoleAdminChanged(role, previousAdminRole, adminRole);
//     }

//     /**
//      * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
//      *
//      * Internal function without access restriction.
//      *
//      * May emit a {RoleGranted} event.
//      */
//     function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
//         AccessControlStorage storage $ = _getAccessControlStorage();
//         if (!hasRole(role, account)) {
//             $._roles[role].hasRole[account] = true;
//             emit RoleGranted(role, account, _msgSender());
//             return true;
//         } else {
//             return false;
//         }
//     }

//     /**
//      * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.
//      *
//      * Internal function without access restriction.
//      *
//      * May emit a {RoleRevoked} event.
//      */
//     function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
//         AccessControlStorage storage $ = _getAccessControlStorage();
//         if (hasRole(role, account)) {
//             $._roles[role].hasRole[account] = false;
//             emit RoleRevoked(role, account, _msgSender());
//             return true;
//         } else {
//             return false;
//         }
//     }
// }


// // File @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)

// pragma solidity ^0.8.20;


// /**
//  * @dev Contract module which provides a basic access control mechanism, where
//  * there is an account (an owner) that can be granted exclusive access to
//  * specific functions.
//  *
//  * The initial owner is set to the address provided by the deployer. This can
//  * later be changed with {transferOwnership}.
//  *
//  * This module is used through inheritance. It will make available the modifier
//  * `onlyOwner`, which can be applied to your functions to restrict their use to
//  * the owner.
//  */
// abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
//     /// @custom:storage-location erc7201:openzeppelin.storage.Ownable
//     struct OwnableStorage {
//         address _owner;
//     }

//     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))
//     bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;

//     function _getOwnableStorage() private pure returns (OwnableStorage storage $) {
//         assembly {
//             $.slot := OwnableStorageLocation
//         }
//     }

//     /**
//      * @dev The caller account is not authorized to perform an operation.
//      */
//     error OwnableUnauthorizedAccount(address account);

//     /**
//      * @dev The owner is not a valid owner account. (eg. `address(0)`)
//      */
//     error OwnableInvalidOwner(address owner);

//     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

//     /**
//      * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
//      */
//     function __Ownable_init(address initialOwner) internal onlyInitializing {
//         __Ownable_init_unchained(initialOwner);
//     }

//     function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {
//         if (initialOwner == address(0)) {
//             revert OwnableInvalidOwner(address(0));
//         }
//         _transferOwnership(initialOwner);
//     }

//     /**
//      * @dev Throws if called by any account other than the owner.
//      */
//     modifier onlyOwner() {
//         _checkOwner();
//         _;
//     }

//     /**
//      * @dev Returns the address of the current owner.
//      */
//     function owner() public view virtual returns (address) {
//         OwnableStorage storage $ = _getOwnableStorage();
//         return $._owner;
//     }

//     /**
//      * @dev Throws if the sender is not the owner.
//      */
//     function _checkOwner() internal view virtual {
//         if (owner() != _msgSender()) {
//             revert OwnableUnauthorizedAccount(_msgSender());
//         }
//     }

//     /**
//      * @dev Leaves the contract without owner. It will not be possible to call
//      * `onlyOwner` functions. Can only be called by the current owner.
//      *
//      * NOTE: Renouncing ownership will leave the contract without an owner,
//      * thereby disabling any functionality that is only available to the owner.
//      */
//     function renounceOwnership() public virtual onlyOwner {
//         _transferOwnership(address(0));
//     }

//     /**
//      * @dev Transfers ownership of the contract to a new account (`newOwner`).
//      * Can only be called by the current owner.
//      */
//     function transferOwnership(address newOwner) public virtual onlyOwner {
//         if (newOwner == address(0)) {
//             revert OwnableInvalidOwner(address(0));
//         }
//         _transferOwnership(newOwner);
//     }

//     /**
//      * @dev Transfers ownership of the contract to a new account (`newOwner`).
//      * Internal function without access restriction.
//      */
//     function _transferOwnership(address newOwner) internal virtual {
//         OwnableStorage storage $ = _getOwnableStorage();
//         address oldOwner = $._owner;
//         $._owner = newOwner;
//         emit OwnershipTransferred(oldOwner, newOwner);
//     }
// }


// // File @openzeppelin/contracts/interfaces/draft-IERC6093.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)
// pragma solidity ^0.8.20;

// /**
//  * @dev Standard ERC20 Errors
//  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.
//  */
// interface IERC20Errors {
//     /**
//      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
//      * @param sender Address whose tokens are being transferred.
//      * @param balance Current balance for the interacting account.
//      * @param needed Minimum amount required to perform a transfer.
//      */
//     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);

//     /**
//      * @dev Indicates a failure with the token `sender`. Used in transfers.
//      * @param sender Address whose tokens are being transferred.
//      */
//     error ERC20InvalidSender(address sender);

//     /**
//      * @dev Indicates a failure with the token `receiver`. Used in transfers.
//      * @param receiver Address to which tokens are being transferred.
//      */
//     error ERC20InvalidReceiver(address receiver);

//     /**
//      * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
//      * @param spender Address that may be allowed to operate on tokens without being their owner.
//      * @param allowance Amount of tokens a `spender` is allowed to operate with.
//      * @param needed Minimum amount required to perform a transfer.
//      */
//     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);

//     /**
//      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
//      * @param approver Address initiating an approval operation.
//      */
//     error ERC20InvalidApprover(address approver);

//     /**
//      * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
//      * @param spender Address that may be allowed to operate on tokens without being their owner.
//      */
//     error ERC20InvalidSpender(address spender);
// }

// /**
//  * @dev Standard ERC721 Errors
//  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.
//  */
// interface IERC721Errors {
//     /**
//      * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.
//      * Used in balance queries.
//      * @param owner Address of the current owner of a token.
//      */
//     error ERC721InvalidOwner(address owner);

//     /**
//      * @dev Indicates a `tokenId` whose `owner` is the zero address.
//      * @param tokenId Identifier number of a token.
//      */
//     error ERC721NonexistentToken(uint256 tokenId);

//     /**
//      * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
//      * @param sender Address whose tokens are being transferred.
//      * @param tokenId Identifier number of a token.
//      * @param owner Address of the current owner of a token.
//      */
//     error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);

//     /**
//      * @dev Indicates a failure with the token `sender`. Used in transfers.
//      * @param sender Address whose tokens are being transferred.
//      */
//     error ERC721InvalidSender(address sender);

//     /**
//      * @dev Indicates a failure with the token `receiver`. Used in transfers.
//      * @param receiver Address to which tokens are being transferred.
//      */
//     error ERC721InvalidReceiver(address receiver);

//     /**
//      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
//      * @param operator Address that may be allowed to operate on tokens without being their owner.
//      * @param tokenId Identifier number of a token.
//      */
//     error ERC721InsufficientApproval(address operator, uint256 tokenId);

//     /**
//      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
//      * @param approver Address initiating an approval operation.
//      */
//     error ERC721InvalidApprover(address approver);

//     /**
//      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
//      * @param operator Address that may be allowed to operate on tokens without being their owner.
//      */
//     error ERC721InvalidOperator(address operator);
// }

// /**
//  * @dev Standard ERC1155 Errors
//  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.
//  */
// interface IERC1155Errors {
//     /**
//      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
//      * @param sender Address whose tokens are being transferred.
//      * @param balance Current balance for the interacting account.
//      * @param needed Minimum amount required to perform a transfer.
//      * @param tokenId Identifier number of a token.
//      */
//     error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);

//     /**
//      * @dev Indicates a failure with the token `sender`. Used in transfers.
//      * @param sender Address whose tokens are being transferred.
//      */
//     error ERC1155InvalidSender(address sender);

//     /**
//      * @dev Indicates a failure with the token `receiver`. Used in transfers.
//      * @param receiver Address to which tokens are being transferred.
//      */
//     error ERC1155InvalidReceiver(address receiver);

//     /**
//      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
//      * @param operator Address that may be allowed to operate on tokens without being their owner.
//      * @param owner Address of the current owner of a token.
//      */
//     error ERC1155MissingApprovalForAll(address operator, address owner);

//     /**
//      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
//      * @param approver Address initiating an approval operation.
//      */
//     error ERC1155InvalidApprover(address approver);

//     /**
//      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
//      * @param operator Address that may be allowed to operate on tokens without being their owner.
//      */
//     error ERC1155InvalidOperator(address operator);

//     /**
//      * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
//      * Used in batch transfers.
//      * @param idsLength Length of the array of token identifiers
//      * @param valuesLength Length of the array of token amounts
//      */
//     error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
// }


// // File @openzeppelin/contracts/token/ERC20/IERC20.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Interface of the ERC20 standard as defined in the EIP.
//  */
// interface IERC20 {
//     /**
//      * @dev Emitted when `value` tokens are moved from one account (`from`) to
//      * another (`to`).
//      *
//      * Note that `value` may be zero.
//      */
//     event Transfer(address indexed from, address indexed to, uint256 value);

//     /**
//      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
//      * a call to {approve}. `value` is the new allowance.
//      */
//     event Approval(address indexed owner, address indexed spender, uint256 value);

//     /**
//      * @dev Returns the value of tokens in existence.
//      */
//     function totalSupply() external view returns (uint256);

//     /**
//      * @dev Returns the value of tokens owned by `account`.
//      */
//     function balanceOf(address account) external view returns (uint256);

//     /**
//      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
//      *
//      * Returns a boolean value indicating whether the operation succeeded.
//      *
//      * Emits a {Transfer} event.
//      */
//     function transfer(address to, uint256 value) external returns (bool);

//     /**
//      * @dev Returns the remaining number of tokens that `spender` will be
//      * allowed to spend on behalf of `owner` through {transferFrom}. This is
//      * zero by default.
//      *
//      * This value changes when {approve} or {transferFrom} are called.
//      */
//     function allowance(address owner, address spender) external view returns (uint256);

//     /**
//      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
//      * caller's tokens.
//      *
//      * Returns a boolean value indicating whether the operation succeeded.
//      *
//      * IMPORTANT: Beware that changing an allowance with this method brings the risk
//      * that someone may use both the old and the new allowance by unfortunate
//      * transaction ordering. One possible solution to mitigate this race
//      * condition is to first reduce the spender's allowance to 0 and set the
//      * desired value afterwards:
//      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
//      *
//      * Emits an {Approval} event.
//      */
//     function approve(address spender, uint256 value) external returns (bool);

//     /**
//      * @dev Moves a `value` amount of tokens from `from` to `to` using the
//      * allowance mechanism. `value` is then deducted from the caller's
//      * allowance.
//      *
//      * Returns a boolean value indicating whether the operation succeeded.
//      *
//      * Emits a {Transfer} event.
//      */
//     function transferFrom(address from, address to, uint256 value) external returns (bool);
// }


// // File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Interface for the optional metadata functions from the ERC20 standard.
//  */
// interface IERC20Metadata is IERC20 {
//     /**
//      * @dev Returns the name of the token.
//      */
//     function name() external view returns (string memory);

//     /**
//      * @dev Returns the symbol of the token.
//      */
//     function symbol() external view returns (string memory);

//     /**
//      * @dev Returns the decimals places of the token.
//      */
//     function decimals() external view returns (uint8);
// }


// // File @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)

// pragma solidity ^0.8.20;





// /**
//  * @dev Implementation of the {IERC20} interface.
//  *
//  * This implementation is agnostic to the way tokens are created. This means
//  * that a supply mechanism has to be added in a derived contract using {_mint}.
//  *
//  * TIP: For a detailed writeup see our guide
//  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
//  * to implement supply mechanisms].
//  *
//  * The default value of {decimals} is 18. To change this, you should override
//  * this function so it returns a different value.
//  *
//  * We have followed general OpenZeppelin Contracts guidelines: functions revert
//  * instead returning `false` on failure. This behavior is nonetheless
//  * conventional and does not conflict with the expectations of ERC20
//  * applications.
//  *
//  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
//  * This allows applications to reconstruct the allowance for all accounts just
//  * by listening to said events. Other implementations of the EIP may not emit
//  * these events, as it isn't required by the specification.
//  */
// abstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {
//     /// @custom:storage-location erc7201:openzeppelin.storage.ERC20
//     struct ERC20Storage {
//         mapping(address account => uint256) _balances;

//         mapping(address account => mapping(address spender => uint256)) _allowances;

//         uint256 _totalSupply;

//         string _name;
//         string _symbol;
//     }

//     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ERC20")) - 1)) & ~bytes32(uint256(0xff))
//     bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;

//     function _getERC20Storage() private pure returns (ERC20Storage storage $) {
//         assembly {
//             $.slot := ERC20StorageLocation
//         }
//     }

//     /**
//      * @dev Sets the values for {name} and {symbol}.
//      *
//      * All two of these values are immutable: they can only be set once during
//      * construction.
//      */
//     function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {
//         __ERC20_init_unchained(name_, symbol_);
//     }

//     function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {
//         ERC20Storage storage $ = _getERC20Storage();
//         $._name = name_;
//         $._symbol = symbol_;
//     }

//     /**
//      * @dev Returns the name of the token.
//      */
//     function name() public view virtual returns (string memory) {
//         ERC20Storage storage $ = _getERC20Storage();
//         return $._name;
//     }

//     /**
//      * @dev Returns the symbol of the token, usually a shorter version of the
//      * name.
//      */
//     function symbol() public view virtual returns (string memory) {
//         ERC20Storage storage $ = _getERC20Storage();
//         return $._symbol;
//     }

//     /**
//      * @dev Returns the number of decimals used to get its user representation.
//      * For example, if `decimals` equals `2`, a balance of `505` tokens should
//      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
//      *
//      * Tokens usually opt for a value of 18, imitating the relationship between
//      * Ether and Wei. This is the default value returned by this function, unless
//      * it's overridden.
//      *
//      * NOTE: This information is only used for _display_ purposes: it in
//      * no way affects any of the arithmetic of the contract, including
//      * {IERC20-balanceOf} and {IERC20-transfer}.
//      */
//     function decimals() public view virtual returns (uint8) {
//         return 18;
//     }

//     /**
//      * @dev See {IERC20-totalSupply}.
//      */
//     function totalSupply() public view virtual returns (uint256) {
//         ERC20Storage storage $ = _getERC20Storage();
//         return $._totalSupply;
//     }

//     /**
//      * @dev See {IERC20-balanceOf}.
//      */
//     function balanceOf(address account) public view virtual returns (uint256) {
//         ERC20Storage storage $ = _getERC20Storage();
//         return $._balances[account];
//     }

//     /**
//      * @dev See {IERC20-transfer}.
//      *
//      * Requirements:
//      *
//      * - `to` cannot be the zero address.
//      * - the caller must have a balance of at least `value`.
//      */
//     function transfer(address to, uint256 value) public virtual returns (bool) {
//         address owner = _msgSender();
//         _transfer(owner, to, value);
//         return true;
//     }

//     /**
//      * @dev See {IERC20-allowance}.
//      */
//     function allowance(address owner, address spender) public view virtual returns (uint256) {
//         ERC20Storage storage $ = _getERC20Storage();
//         return $._allowances[owner][spender];
//     }

//     /**
//      * @dev See {IERC20-approve}.
//      *
//      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
//      * `transferFrom`. This is semantically equivalent to an infinite approval.
//      *
//      * Requirements:
//      *
//      * - `spender` cannot be the zero address.
//      */
//     function approve(address spender, uint256 value) public virtual returns (bool) {
//         address owner = _msgSender();
//         _approve(owner, spender, value);
//         return true;
//     }

//     /**
//      * @dev See {IERC20-transferFrom}.
//      *
//      * Emits an {Approval} event indicating the updated allowance. This is not
//      * required by the EIP. See the note at the beginning of {ERC20}.
//      *
//      * NOTE: Does not update the allowance if the current allowance
//      * is the maximum `uint256`.
//      *
//      * Requirements:
//      *
//      * - `from` and `to` cannot be the zero address.
//      * - `from` must have a balance of at least `value`.
//      * - the caller must have allowance for ``from``'s tokens of at least
//      * `value`.
//      */
//     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
//         address spender = _msgSender();
//         _spendAllowance(from, spender, value);
//         _transfer(from, to, value);
//         return true;
//     }

//     /**
//      * @dev Moves a `value` amount of tokens from `from` to `to`.
//      *
//      * This internal function is equivalent to {transfer}, and can be used to
//      * e.g. implement automatic token fees, slashing mechanisms, etc.
//      *
//      * Emits a {Transfer} event.
//      *
//      * NOTE: This function is not virtual, {_update} should be overridden instead.
//      */
//     function _transfer(address from, address to, uint256 value) internal {
//         if (from == address(0)) {
//             revert ERC20InvalidSender(address(0));
//         }
//         if (to == address(0)) {
//             revert ERC20InvalidReceiver(address(0));
//         }
//         _update(from, to, value);
//     }

//     /**
//      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
//      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
//      * this function.
//      *
//      * Emits a {Transfer} event.
//      */
//     function _update(address from, address to, uint256 value) internal virtual {
//         ERC20Storage storage $ = _getERC20Storage();
//         if (from == address(0)) {
//             // Overflow check required: The rest of the code assumes that totalSupply never overflows
//             $._totalSupply += value;
//         } else {
//             uint256 fromBalance = $._balances[from];
//             if (fromBalance < value) {
//                 revert ERC20InsufficientBalance(from, fromBalance, value);
//             }
//             unchecked {
//                 // Overflow not possible: value <= fromBalance <= totalSupply.
//                 $._balances[from] = fromBalance - value;
//             }
//         }

//         if (to == address(0)) {
//             unchecked {
//                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
//                 $._totalSupply -= value;
//             }
//         } else {
//             unchecked {
//                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
//                 $._balances[to] += value;
//             }
//         }

//         emit Transfer(from, to, value);
//     }

//     /**
//      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
//      * Relies on the `_update` mechanism
//      *
//      * Emits a {Transfer} event with `from` set to the zero address.
//      *
//      * NOTE: This function is not virtual, {_update} should be overridden instead.
//      */
//     function _mint(address account, uint256 value) internal {
//         if (account == address(0)) {
//             revert ERC20InvalidReceiver(address(0));
//         }
//         _update(address(0), account, value);
//     }

//     /**
//      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
//      * Relies on the `_update` mechanism.
//      *
//      * Emits a {Transfer} event with `to` set to the zero address.
//      *
//      * NOTE: This function is not virtual, {_update} should be overridden instead
//      */
//     function _burn(address account, uint256 value) internal {
//         if (account == address(0)) {
//             revert ERC20InvalidSender(address(0));
//         }
//         _update(account, address(0), value);
//     }

//     /**
//      * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.
//      *
//      * This internal function is equivalent to `approve`, and can be used to
//      * e.g. set automatic allowances for certain subsystems, etc.
//      *
//      * Emits an {Approval} event.
//      *
//      * Requirements:
//      *
//      * - `owner` cannot be the zero address.
//      * - `spender` cannot be the zero address.
//      *
//      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
//      */
//     function _approve(address owner, address spender, uint256 value) internal {
//         _approve(owner, spender, value, true);
//     }

//     /**
//      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
//      *
//      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
//      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
//      * `Approval` event during `transferFrom` operations.
//      *
//      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
//      * true using the following override:
//      * ```
//      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
//      *     super._approve(owner, spender, value, true);
//      * }
//      * ```
//      *
//      * Requirements are the same as {_approve}.
//      */
//     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
//         ERC20Storage storage $ = _getERC20Storage();
//         if (owner == address(0)) {
//             revert ERC20InvalidApprover(address(0));
//         }
//         if (spender == address(0)) {
//             revert ERC20InvalidSpender(address(0));
//         }
//         $._allowances[owner][spender] = value;
//         if (emitEvent) {
//             emit Approval(owner, spender, value);
//         }
//     }

//     /**
//      * @dev Updates `owner` s allowance for `spender` based on spent `value`.
//      *
//      * Does not update the allowance value in case of infinite allowance.
//      * Revert if not enough allowance is available.
//      *
//      * Does not emit an {Approval} event.
//      */
//     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
//         uint256 currentAllowance = allowance(owner, spender);
//         if (currentAllowance != type(uint256).max) {
//             if (currentAllowance < value) {
//                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
//             }
//             unchecked {
//                 _approve(owner, spender, currentAllowance - value, false);
//             }
//         }
//     }
// }


// // File @openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)

// pragma solidity ^0.8.20;


// /**
//  * @dev Contract module which allows children to implement an emergency stop
//  * mechanism that can be triggered by an authorized account.
//  *
//  * This module is used through inheritance. It will make available the
//  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
//  * the functions of your contract. Note that they will not be pausable by
//  * simply including this module, only once the modifiers are put in place.
//  */
// abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {
//     /// @custom:storage-location erc7201:openzeppelin.storage.Pausable
//     struct PausableStorage {
//         bool _paused;
//     }

//     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))
//     bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;

//     function _getPausableStorage() private pure returns (PausableStorage storage $) {
//         assembly {
//             $.slot := PausableStorageLocation
//         }
//     }

//     /**
//      * @dev Emitted when the pause is triggered by `account`.
//      */
//     event Paused(address account);

//     /**
//      * @dev Emitted when the pause is lifted by `account`.
//      */
//     event Unpaused(address account);

//     /**
//      * @dev The operation failed because the contract is paused.
//      */
//     error EnforcedPause();

//     /**
//      * @dev The operation failed because the contract is not paused.
//      */
//     error ExpectedPause();

//     /**
//      * @dev Initializes the contract in unpaused state.
//      */
//     function __Pausable_init() internal onlyInitializing {
//         __Pausable_init_unchained();
//     }

//     function __Pausable_init_unchained() internal onlyInitializing {
//         PausableStorage storage $ = _getPausableStorage();
//         $._paused = false;
//     }

//     /**
//      * @dev Modifier to make a function callable only when the contract is not paused.
//      *
//      * Requirements:
//      *
//      * - The contract must not be paused.
//      */
//     modifier whenNotPaused() {
//         _requireNotPaused();
//         _;
//     }

//     /**
//      * @dev Modifier to make a function callable only when the contract is paused.
//      *
//      * Requirements:
//      *
//      * - The contract must be paused.
//      */
//     modifier whenPaused() {
//         _requirePaused();
//         _;
//     }

//     /**
//      * @dev Returns true if the contract is paused, and false otherwise.
//      */
//     function paused() public view virtual returns (bool) {
//         PausableStorage storage $ = _getPausableStorage();
//         return $._paused;
//     }

//     /**
//      * @dev Throws if the contract is paused.
//      */
//     function _requireNotPaused() internal view virtual {
//         if (paused()) {
//             revert EnforcedPause();
//         }
//     }

//     /**
//      * @dev Throws if the contract is not paused.
//      */
//     function _requirePaused() internal view virtual {
//         if (!paused()) {
//             revert ExpectedPause();
//         }
//     }

//     /**
//      * @dev Triggers stopped state.
//      *
//      * Requirements:
//      *
//      * - The contract must not be paused.
//      */
//     function _pause() internal virtual whenNotPaused {
//         PausableStorage storage $ = _getPausableStorage();
//         $._paused = true;
//         emit Paused(_msgSender());
//     }

//     /**
//      * @dev Returns to normal state.
//      *
//      * Requirements:
//      *
//      * - The contract must be paused.
//      */
//     function _unpause() internal virtual whenPaused {
//         PausableStorage storage $ = _getPausableStorage();
//         $._paused = false;
//         emit Unpaused(_msgSender());
//     }
// }


// // File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Pausable.sol)

// pragma solidity ^0.8.20;



// /**
//  * @dev ERC20 token with pausable token transfers, minting and burning.
//  *
//  * Useful for scenarios such as preventing trades until the end of an evaluation
//  * period, or having an emergency switch for freezing all token transfers in the
//  * event of a large bug.
//  *
//  * IMPORTANT: This contract does not include public pause and unpause functions. In
//  * addition to inheriting this contract, you must define both functions, invoking the
//  * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate
//  * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will
//  * make the contract pause mechanism of the contract unreachable, and thus unusable.
//  */
// abstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {
//     function __ERC20Pausable_init() internal onlyInitializing {
//         __Pausable_init_unchained();
//     }

//     function __ERC20Pausable_init_unchained() internal onlyInitializing {
//     }
//     /**
//      * @dev See {ERC20-_update}.
//      *
//      * Requirements:
//      *
//      * - the contract must not be paused.
//      */
//     function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {
//         super._update(from, to, value);
//     }
// }


// // File @openzeppelin/contracts/interfaces/IERC5267.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)

// pragma solidity ^0.8.20;

// interface IERC5267 {
//     /**
//      * @dev MAY be emitted to signal that the domain could have changed.
//      */
//     event EIP712DomainChanged();

//     /**
//      * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712
//      * signature.
//      */
//     function eip712Domain()
//         external
//         view
//         returns (
//             bytes1 fields,
//             string memory name,
//             string memory version,
//             uint256 chainId,
//             address verifyingContract,
//             bytes32 salt,
//             uint256[] memory extensions
//         );
// }


// // File @openzeppelin/contracts/utils/math/Math.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Standard math utilities missing in the Solidity language.
//  */
// library Math {
//     /**
//      * @dev Muldiv operation overflow.
//      */
//     error MathOverflowedMulDiv();

//     enum Rounding {
//         Floor, // Toward negative infinity
//         Ceil, // Toward positive infinity
//         Trunc, // Toward zero
//         Expand // Away from zero
//     }

//     /**
//      * @dev Returns the addition of two unsigned integers, with an overflow flag.
//      */
//     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
//         unchecked {
//             uint256 c = a + b;
//             if (c < a) return (false, 0);
//             return (true, c);
//         }
//     }

//     /**
//      * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
//      */
//     function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
//         unchecked {
//             if (b > a) return (false, 0);
//             return (true, a - b);
//         }
//     }

//     /**
//      * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
//      */
//     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
//         unchecked {
//             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
//             // benefit is lost if 'b' is also tested.
//             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
//             if (a == 0) return (true, 0);
//             uint256 c = a * b;
//             if (c / a != b) return (false, 0);
//             return (true, c);
//         }
//     }

//     /**
//      * @dev Returns the division of two unsigned integers, with a division by zero flag.
//      */
//     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
//         unchecked {
//             if (b == 0) return (false, 0);
//             return (true, a / b);
//         }
//     }

//     /**
//      * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
//      */
//     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
//         unchecked {
//             if (b == 0) return (false, 0);
//             return (true, a % b);
//         }
//     }

//     /**
//      * @dev Returns the largest of two numbers.
//      */
//     function max(uint256 a, uint256 b) internal pure returns (uint256) {
//         return a > b ? a : b;
//     }

//     /**
//      * @dev Returns the smallest of two numbers.
//      */
//     function min(uint256 a, uint256 b) internal pure returns (uint256) {
//         return a < b ? a : b;
//     }

//     /**
//      * @dev Returns the average of two numbers. The result is rounded towards
//      * zero.
//      */
//     function average(uint256 a, uint256 b) internal pure returns (uint256) {
//         // (a + b) / 2 can overflow.
//         return (a & b) + (a ^ b) / 2;
//     }

//     /**
//      * @dev Returns the ceiling of the division of two numbers.
//      *
//      * This differs from standard division with `/` in that it rounds towards infinity instead
//      * of rounding towards zero.
//      */
//     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
//         if (b == 0) {
//             // Guarantee the same behavior as in a regular Solidity division.
//             return a / b;
//         }

//         // (a + b - 1) / b can overflow on addition, so we distribute.
//         return a == 0 ? 0 : (a - 1) / b + 1;
//     }

//     /**
//      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or
//      * denominator == 0.
//      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by
//      * Uniswap Labs also under MIT license.
//      */
//     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
//         unchecked {
//             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
//             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
//             // variables such that product = prod1 * 2^256 + prod0.
//             uint256 prod0 = x * y; // Least significant 256 bits of the product
//             uint256 prod1; // Most significant 256 bits of the product
//             assembly {
//                 let mm := mulmod(x, y, not(0))
//                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
//             }

//             // Handle non-overflow cases, 256 by 256 division.
//             if (prod1 == 0) {
//                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
//                 // The surrounding unchecked block does not change this fact.
//                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
//                 return prod0 / denominator;
//             }

//             // Make sure the result is less than 2^256. Also prevents denominator == 0.
//             if (denominator <= prod1) {
//                 revert MathOverflowedMulDiv();
//             }

//             ///////////////////////////////////////////////
//             // 512 by 256 division.
//             ///////////////////////////////////////////////

//             // Make division exact by subtracting the remainder from [prod1 prod0].
//             uint256 remainder;
//             assembly {
//                 // Compute remainder using mulmod.
//                 remainder := mulmod(x, y, denominator)

//                 // Subtract 256 bit number from 512 bit number.
//                 prod1 := sub(prod1, gt(remainder, prod0))
//                 prod0 := sub(prod0, remainder)
//             }

//             // Factor powers of two out of denominator and compute largest power of two divisor of denominator.
//             // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.

//             uint256 twos = denominator & (0 - denominator);
//             assembly {
//                 // Divide denominator by twos.
//                 denominator := div(denominator, twos)

//                 // Divide [prod1 prod0] by twos.
//                 prod0 := div(prod0, twos)

//                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
//                 twos := add(div(sub(0, twos), twos), 1)
//             }

//             // Shift in bits from prod1 into prod0.
//             prod0 |= prod1 * twos;

//             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
//             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
//             // four bits. That is, denominator * inv = 1 mod 2^4.
//             uint256 inverse = (3 * denominator) ^ 2;

//             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also
//             // works in modular arithmetic, doubling the correct bits in each step.
//             inverse *= 2 - denominator * inverse; // inverse mod 2^8
//             inverse *= 2 - denominator * inverse; // inverse mod 2^16
//             inverse *= 2 - denominator * inverse; // inverse mod 2^32
//             inverse *= 2 - denominator * inverse; // inverse mod 2^64
//             inverse *= 2 - denominator * inverse; // inverse mod 2^128
//             inverse *= 2 - denominator * inverse; // inverse mod 2^256

//             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
//             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
//             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
//             // is no longer required.
//             result = prod0 * inverse;
//             return result;
//         }
//     }

//     /**
//      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
//      */
//     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
//         uint256 result = mulDiv(x, y, denominator);
//         if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {
//             result += 1;
//         }
//         return result;
//     }

//     /**
//      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded
//      * towards zero.
//      *
//      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
//      */
//     function sqrt(uint256 a) internal pure returns (uint256) {
//         if (a == 0) {
//             return 0;
//         }

//         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
//         //
//         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
//         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
//         //
//         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
//         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
//         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
//         //
//         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
//         uint256 result = 1 << (log2(a) >> 1);

//         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
//         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
//         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
//         // into the expected uint128 result.
//         unchecked {
//             result = (result + a / result) >> 1;
//             result = (result + a / result) >> 1;
//             result = (result + a / result) >> 1;
//             result = (result + a / result) >> 1;
//             result = (result + a / result) >> 1;
//             result = (result + a / result) >> 1;
//             result = (result + a / result) >> 1;
//             return min(result, a / result);
//         }
//     }

//     /**
//      * @notice Calculates sqrt(a), following the selected rounding direction.
//      */
//     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
//         unchecked {
//             uint256 result = sqrt(a);
//             return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);
//         }
//     }

//     /**
//      * @dev Return the log in base 2 of a positive value rounded towards zero.
//      * Returns 0 if given 0.
//      */
//     function log2(uint256 value) internal pure returns (uint256) {
//         uint256 result = 0;
//         unchecked {
//             if (value >> 128 > 0) {
//                 value >>= 128;
//                 result += 128;
//             }
//             if (value >> 64 > 0) {
//                 value >>= 64;
//                 result += 64;
//             }
//             if (value >> 32 > 0) {
//                 value >>= 32;
//                 result += 32;
//             }
//             if (value >> 16 > 0) {
//                 value >>= 16;
//                 result += 16;
//             }
//             if (value >> 8 > 0) {
//                 value >>= 8;
//                 result += 8;
//             }
//             if (value >> 4 > 0) {
//                 value >>= 4;
//                 result += 4;
//             }
//             if (value >> 2 > 0) {
//                 value >>= 2;
//                 result += 2;
//             }
//             if (value >> 1 > 0) {
//                 result += 1;
//             }
//         }
//         return result;
//     }

//     /**
//      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
//      * Returns 0 if given 0.
//      */
//     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
//         unchecked {
//             uint256 result = log2(value);
//             return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);
//         }
//     }

//     /**
//      * @dev Return the log in base 10 of a positive value rounded towards zero.
//      * Returns 0 if given 0.
//      */
//     function log10(uint256 value) internal pure returns (uint256) {
//         uint256 result = 0;
//         unchecked {
//             if (value >= 10 ** 64) {
//                 value /= 10 ** 64;
//                 result += 64;
//             }
//             if (value >= 10 ** 32) {
//                 value /= 10 ** 32;
//                 result += 32;
//             }
//             if (value >= 10 ** 16) {
//                 value /= 10 ** 16;
//                 result += 16;
//             }
//             if (value >= 10 ** 8) {
//                 value /= 10 ** 8;
//                 result += 8;
//             }
//             if (value >= 10 ** 4) {
//                 value /= 10 ** 4;
//                 result += 4;
//             }
//             if (value >= 10 ** 2) {
//                 value /= 10 ** 2;
//                 result += 2;
//             }
//             if (value >= 10 ** 1) {
//                 result += 1;
//             }
//         }
//         return result;
//     }

//     /**
//      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
//      * Returns 0 if given 0.
//      */
//     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
//         unchecked {
//             uint256 result = log10(value);
//             return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);
//         }
//     }

//     /**
//      * @dev Return the log in base 256 of a positive value rounded towards zero.
//      * Returns 0 if given 0.
//      *
//      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
//      */
//     function log256(uint256 value) internal pure returns (uint256) {
//         uint256 result = 0;
//         unchecked {
//             if (value >> 128 > 0) {
//                 value >>= 128;
//                 result += 16;
//             }
//             if (value >> 64 > 0) {
//                 value >>= 64;
//                 result += 8;
//             }
//             if (value >> 32 > 0) {
//                 value >>= 32;
//                 result += 4;
//             }
//             if (value >> 16 > 0) {
//                 value >>= 16;
//                 result += 2;
//             }
//             if (value >> 8 > 0) {
//                 result += 1;
//             }
//         }
//         return result;
//     }

//     /**
//      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
//      * Returns 0 if given 0.
//      */
//     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
//         unchecked {
//             uint256 result = log256(value);
//             return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);
//         }
//     }

//     /**
//      * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.
//      */
//     function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {
//         return uint8(rounding) % 2 == 1;
//     }
// }


// // File @openzeppelin/contracts/utils/math/SignedMath.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Standard signed math utilities missing in the Solidity language.
//  */
// library SignedMath {
//     /**
//      * @dev Returns the largest of two signed numbers.
//      */
//     function max(int256 a, int256 b) internal pure returns (int256) {
//         return a > b ? a : b;
//     }

//     /**
//      * @dev Returns the smallest of two signed numbers.
//      */
//     function min(int256 a, int256 b) internal pure returns (int256) {
//         return a < b ? a : b;
//     }

//     /**
//      * @dev Returns the average of two signed numbers without overflow.
//      * The result is rounded towards zero.
//      */
//     function average(int256 a, int256 b) internal pure returns (int256) {
//         // Formula from the book "Hacker's Delight"
//         int256 x = (a & b) + ((a ^ b) >> 1);
//         return x + (int256(uint256(x) >> 255) & (a ^ b));
//     }

//     /**
//      * @dev Returns the absolute unsigned value of a signed value.
//      */
//     function abs(int256 n) internal pure returns (uint256) {
//         unchecked {
//             // must be unchecked in order to support `n = type(int256).min`
//             return uint256(n >= 0 ? n : -n);
//         }
//     }
// }


// // File @openzeppelin/contracts/utils/Strings.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)

// pragma solidity ^0.8.20;


// /**
//  * @dev String operations.
//  */
// library Strings {
//     bytes16 private constant HEX_DIGITS = "0123456789abcdef";
//     uint8 private constant ADDRESS_LENGTH = 20;

//     /**
//      * @dev The `value` string doesn't fit in the specified `length`.
//      */
//     error StringsInsufficientHexLength(uint256 value, uint256 length);

//     /**
//      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
//      */
//     function toString(uint256 value) internal pure returns (string memory) {
//         unchecked {
//             uint256 length = Math.log10(value) + 1;
//             string memory buffer = new string(length);
//             uint256 ptr;
//             /// @solidity memory-safe-assembly
//             assembly {
//                 ptr := add(buffer, add(32, length))
//             }
//             while (true) {
//                 ptr--;
//                 /// @solidity memory-safe-assembly
//                 assembly {
//                     mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))
//                 }
//                 value /= 10;
//                 if (value == 0) break;
//             }
//             return buffer;
//         }
//     }

//     /**
//      * @dev Converts a `int256` to its ASCII `string` decimal representation.
//      */
//     function toStringSigned(int256 value) internal pure returns (string memory) {
//         return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));
//     }

//     /**
//      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
//      */
//     function toHexString(uint256 value) internal pure returns (string memory) {
//         unchecked {
//             return toHexString(value, Math.log256(value) + 1);
//         }
//     }

//     /**
//      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
//      */
//     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
//         uint256 localValue = value;
//         bytes memory buffer = new bytes(2 * length + 2);
//         buffer[0] = "0";
//         buffer[1] = "x";
//         for (uint256 i = 2 * length + 1; i > 1; --i) {
//             buffer[i] = HEX_DIGITS[localValue & 0xf];
//             localValue >>= 4;
//         }
//         if (localValue != 0) {
//             revert StringsInsufficientHexLength(value, length);
//         }
//         return string(buffer);
//     }

//     /**
//      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal
//      * representation.
//      */
//     function toHexString(address addr) internal pure returns (string memory) {
//         return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);
//     }

//     /**
//      * @dev Returns true if the two strings are equal.
//      */
//     function equal(string memory a, string memory b) internal pure returns (bool) {
//         return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));
//     }
// }


// // File @openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.
//  *
//  * The library provides methods for generating a hash of a message that conforms to the
//  * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]
//  * specifications.
//  */
// library MessageHashUtils {
//     /**
//      * @dev Returns the keccak256 digest of an EIP-191 signed data with version
//      * `0x45` (`personal_sign` messages).
//      *
//      * The digest is calculated by prefixing a bytes32 `messageHash` with
//      * `"\x19Ethereum Signed Message:\n32"` and hashing the result. It corresponds with the
//      * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.
//      *
//      * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with
//      * keccak256, although any bytes32 value can be safely used because the final digest will
//      * be re-hashed.
//      *
//      * See {ECDSA-recover}.
//      */
//     function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {
//         /// @solidity memory-safe-assembly
//         assembly {
//             mstore(0x00, "\x19Ethereum Signed Message:\n32") // 32 is the bytes-length of messageHash
//             mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix
//             digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)
//         }
//     }

//     /**
//      * @dev Returns the keccak256 digest of an EIP-191 signed data with version
//      * `0x45` (`personal_sign` messages).
//      *
//      * The digest is calculated by prefixing an arbitrary `message` with
//      * `"\x19Ethereum Signed Message:\n" + len(message)` and hashing the result. It corresponds with the
//      * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.
//      *
//      * See {ECDSA-recover}.
//      */
//     function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {
//         return
//             keccak256(bytes.concat("\x19Ethereum Signed Message:\n", bytes(Strings.toString(message.length)), message));
//     }

//     /**
//      * @dev Returns the keccak256 digest of an EIP-191 signed data with version
//      * `0x00` (data with intended validator).
//      *
//      * The digest is calculated by prefixing an arbitrary `data` with `"\x19\x00"` and the intended
//      * `validator` address. Then hashing the result.
//      *
//      * See {ECDSA-recover}.
//      */
//     function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {
//         return keccak256(abi.encodePacked(hex"19_00", validator, data));
//     }

//     /**
//      * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).
//      *
//      * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with
//      * `\x19\x01` and hashing the result. It corresponds to the hash signed by the
//      * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.
//      *
//      * See {ECDSA-recover}.
//      */
//     function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {
//         /// @solidity memory-safe-assembly
//         assembly {
//             let ptr := mload(0x40)
//             mstore(ptr, hex"19_01")
//             mstore(add(ptr, 0x02), domainSeparator)
//             mstore(add(ptr, 0x22), structHash)
//             digest := keccak256(ptr, 0x42)
//         }
//     }
// }


// // File @openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)

// pragma solidity ^0.8.20;



// /**
//  * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.
//  *
//  * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose
//  * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract
//  * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to
//  * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.
//  *
//  * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding
//  * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
//  * ({_hashTypedDataV4}).
//  *
//  * The implementation of the domain separator was designed to be as efficient as possible while still properly updating
//  * the chain id to protect against replay attacks on an eventual fork of the chain.
//  *
//  * NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method
//  * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].
//  *
//  * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain
//  * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the
//  * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.
//  */
// abstract contract EIP712Upgradeable is Initializable, IERC5267 {
//     bytes32 private constant TYPE_HASH =
//         keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");

//     /// @custom:storage-location erc7201:openzeppelin.storage.EIP712
//     struct EIP712Storage {
//         /// @custom:oz-renamed-from _HASHED_NAME
//         bytes32 _hashedName;
//         /// @custom:oz-renamed-from _HASHED_VERSION
//         bytes32 _hashedVersion;

//         string _name;
//         string _version;
//     }

//     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.EIP712")) - 1)) & ~bytes32(uint256(0xff))
//     bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;

//     function _getEIP712Storage() private pure returns (EIP712Storage storage $) {
//         assembly {
//             $.slot := EIP712StorageLocation
//         }
//     }

//     /**
//      * @dev Initializes the domain separator and parameter caches.
//      *
//      * The meaning of `name` and `version` is specified in
//      * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:
//      *
//      * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
//      * - `version`: the current major version of the signing domain.
//      *
//      * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart
//      * contract upgrade].
//      */
//     function __EIP712_init(string memory name, string memory version) internal onlyInitializing {
//         __EIP712_init_unchained(name, version);
//     }

//     function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {
//         EIP712Storage storage $ = _getEIP712Storage();
//         $._name = name;
//         $._version = version;

//         // Reset prior values in storage if upgrading
//         $._hashedName = 0;
//         $._hashedVersion = 0;
//     }

//     /**
//      * @dev Returns the domain separator for the current chain.
//      */
//     function _domainSeparatorV4() internal view returns (bytes32) {
//         return _buildDomainSeparator();
//     }

//     function _buildDomainSeparator() private view returns (bytes32) {
//         return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));
//     }

//     /**
//      * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this
//      * function returns the hash of the fully encoded EIP712 message for this domain.
//      *
//      * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:
//      *
//      * ```solidity
//      * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
//      *     keccak256("Mail(address to,string contents)"),
//      *     mailTo,
//      *     keccak256(bytes(mailContents))
//      * )));
//      * address signer = ECDSA.recover(digest, signature);
//      * ```
//      */
//     function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
//         return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);
//     }

//     /**
//      * @dev See {IERC-5267}.
//      */
//     function eip712Domain()
//         public
//         view
//         virtual
//         returns (
//             bytes1 fields,
//             string memory name,
//             string memory version,
//             uint256 chainId,
//             address verifyingContract,
//             bytes32 salt,
//             uint256[] memory extensions
//         )
//     {
//         EIP712Storage storage $ = _getEIP712Storage();
//         // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized
//         // and the EIP712 domain is not reliable, as it will be missing name and version.
//         require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");

//         return (
//             hex"0f", // 01111
//             _EIP712Name(),
//             _EIP712Version(),
//             block.chainid,
//             address(this),
//             bytes32(0),
//             new uint256[](0)
//         );
//     }

//     /**
//      * @dev The name parameter for the EIP712 domain.
//      *
//      * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs
//      * are a concern.
//      */
//     function _EIP712Name() internal view virtual returns (string memory) {
//         EIP712Storage storage $ = _getEIP712Storage();
//         return $._name;
//     }

//     /**
//      * @dev The version parameter for the EIP712 domain.
//      *
//      * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs
//      * are a concern.
//      */
//     function _EIP712Version() internal view virtual returns (string memory) {
//         EIP712Storage storage $ = _getEIP712Storage();
//         return $._version;
//     }

//     /**
//      * @dev The hash of the name parameter for the EIP712 domain.
//      *
//      * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.
//      */
//     function _EIP712NameHash() internal view returns (bytes32) {
//         EIP712Storage storage $ = _getEIP712Storage();
//         string memory name = _EIP712Name();
//         if (bytes(name).length > 0) {
//             return keccak256(bytes(name));
//         } else {
//             // If the name is empty, the contract may have been upgraded without initializing the new storage.
//             // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.
//             bytes32 hashedName = $._hashedName;
//             if (hashedName != 0) {
//                 return hashedName;
//             } else {
//                 return keccak256("");
//             }
//         }
//     }

//     /**
//      * @dev The hash of the version parameter for the EIP712 domain.
//      *
//      * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.
//      */
//     function _EIP712VersionHash() internal view returns (bytes32) {
//         EIP712Storage storage $ = _getEIP712Storage();
//         string memory version = _EIP712Version();
//         if (bytes(version).length > 0) {
//             return keccak256(bytes(version));
//         } else {
//             // If the version is empty, the contract may have been upgraded without initializing the new storage.
//             // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.
//             bytes32 hashedVersion = $._hashedVersion;
//             if (hashedVersion != 0) {
//                 return hashedVersion;
//             } else {
//                 return keccak256("");
//             }
//         }
//     }
// }


// // File @openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)
// pragma solidity ^0.8.20;

// /**
//  * @dev Provides tracking nonces for addresses. Nonces will only increment.
//  */
// abstract contract NoncesUpgradeable is Initializable {
//     /**
//      * @dev The nonce used for an `account` is not the expected current nonce.
//      */
//     error InvalidAccountNonce(address account, uint256 currentNonce);

//     /// @custom:storage-location erc7201:openzeppelin.storage.Nonces
//     struct NoncesStorage {
//         mapping(address account => uint256) _nonces;
//     }

//     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Nonces")) - 1)) & ~bytes32(uint256(0xff))
//     bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;

//     function _getNoncesStorage() private pure returns (NoncesStorage storage $) {
//         assembly {
//             $.slot := NoncesStorageLocation
//         }
//     }

//     function __Nonces_init() internal onlyInitializing {
//     }

//     function __Nonces_init_unchained() internal onlyInitializing {
//     }
//     /**
//      * @dev Returns the next unused nonce for an address.
//      */
//     function nonces(address owner) public view virtual returns (uint256) {
//         NoncesStorage storage $ = _getNoncesStorage();
//         return $._nonces[owner];
//     }

//     /**
//      * @dev Consumes a nonce.
//      *
//      * Returns the current value and increments nonce.
//      */
//     function _useNonce(address owner) internal virtual returns (uint256) {
//         NoncesStorage storage $ = _getNoncesStorage();
//         // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be
//         // decremented or reset. This guarantees that the nonce never overflows.
//         unchecked {
//             // It is important to do x++ and not ++x here.
//             return $._nonces[owner]++;
//         }
//     }

//     /**
//      * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.
//      */
//     function _useCheckedNonce(address owner, uint256 nonce) internal virtual {
//         uint256 current = _useNonce(owner);
//         if (nonce != current) {
//             revert InvalidAccountNonce(owner, current);
//         }
//     }
// }


// // File @openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
//  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
//  *
//  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
//  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
//  * need to send a transaction, and thus is not required to hold Ether at all.
//  *
//  * ==== Security Considerations
//  *
//  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
//  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
//  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
//  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
//  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
//  * generally recommended is:
//  *
//  * ```solidity
//  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
//  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
//  *     doThing(..., value);
//  * }
//  *
//  * function doThing(..., uint256 value) public {
//  *     token.safeTransferFrom(msg.sender, address(this), value);
//  *     ...
//  * }
//  * ```
//  *
//  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
//  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
//  * {SafeERC20-safeTransferFrom}).
//  *
//  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
//  * contracts should have entry points that don't rely on permit.
//  */
// interface IERC20Permit {
//     /**
//      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
//      * given ``owner``'s signed approval.
//      *
//      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
//      * ordering also apply here.
//      *
//      * Emits an {Approval} event.
//      *
//      * Requirements:
//      *
//      * - `spender` cannot be the zero address.
//      * - `deadline` must be a timestamp in the future.
//      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
//      * over the EIP712-formatted function arguments.
//      * - the signature must use ``owner``'s current nonce (see {nonces}).
//      *
//      * For more information on the signature format, see the
//      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
//      * section].
//      *
//      * CAUTION: See Security Considerations above.
//      */
//     function permit(
//         address owner,
//         address spender,
//         uint256 value,
//         uint256 deadline,
//         uint8 v,
//         bytes32 r,
//         bytes32 s
//     ) external;

//     /**
//      * @dev Returns the current nonce for `owner`. This value must be
//      * included whenever a signature is generated for {permit}.
//      *
//      * Every successful call to {permit} increases ``owner``'s nonce by one. This
//      * prevents a signature from being used multiple times.
//      */
//     function nonces(address owner) external view returns (uint256);

//     /**
//      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
//      */
//     // solhint-disable-next-line func-name-mixedcase
//     function DOMAIN_SEPARATOR() external view returns (bytes32);
// }


// // File @openzeppelin/contracts/utils/cryptography/ECDSA.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
//  *
//  * These functions can be used to verify that a message was signed by the holder
//  * of the private keys of a given address.
//  */
// library ECDSA {
//     enum RecoverError {
//         NoError,
//         InvalidSignature,
//         InvalidSignatureLength,
//         InvalidSignatureS
//     }

//     /**
//      * @dev The signature derives the `address(0)`.
//      */
//     error ECDSAInvalidSignature();

//     /**
//      * @dev The signature has an invalid length.
//      */
//     error ECDSAInvalidSignatureLength(uint256 length);

//     /**
//      * @dev The signature has an S value that is in the upper half order.
//      */
//     error ECDSAInvalidSignatureS(bytes32 s);

//     /**
//      * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not
//      * return address(0) without also returning an error description. Errors are documented using an enum (error type)
//      * and a bytes32 providing additional information about the error.
//      *
//      * If no error is returned, then the address can be used for verification purposes.
//      *
//      * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:
//      * this function rejects them by requiring the `s` value to be in the lower
//      * half order, and the `v` value to be either 27 or 28.
//      *
//      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
//      * verification to be secure: it is possible to craft signatures that
//      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
//      * this is by receiving a hash of the original message (which may otherwise
//      * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.
//      *
//      * Documentation for signature generation:
//      * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
//      * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
//      */
//     function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {
//         if (signature.length == 65) {
//             bytes32 r;
//             bytes32 s;
//             uint8 v;
//             // ecrecover takes the signature parameters, and the only way to get them
//             // currently is to use assembly.
//             /// @solidity memory-safe-assembly
//             assembly {
//                 r := mload(add(signature, 0x20))
//                 s := mload(add(signature, 0x40))
//                 v := byte(0, mload(add(signature, 0x60)))
//             }
//             return tryRecover(hash, v, r, s);
//         } else {
//             return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));
//         }
//     }

//     /**
//      * @dev Returns the address that signed a hashed message (`hash`) with
//      * `signature`. This address can then be used for verification purposes.
//      *
//      * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:
//      * this function rejects them by requiring the `s` value to be in the lower
//      * half order, and the `v` value to be either 27 or 28.
//      *
//      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
//      * verification to be secure: it is possible to craft signatures that
//      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
//      * this is by receiving a hash of the original message (which may otherwise
//      * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.
//      */
//     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
//         (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);
//         _throwError(error, errorArg);
//         return recovered;
//     }

//     /**
//      * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
//      *
//      * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
//      */
//     function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {
//         unchecked {
//             bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
//             // We do not check for an overflow here since the shift operation results in 0 or 1.
//             uint8 v = uint8((uint256(vs) >> 255) + 27);
//             return tryRecover(hash, v, r, s);
//         }
//     }

//     /**
//      * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
//      */
//     function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {
//         (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);
//         _throwError(error, errorArg);
//         return recovered;
//     }

//     /**
//      * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
//      * `r` and `s` signature fields separately.
//      */
//     function tryRecover(
//         bytes32 hash,
//         uint8 v,
//         bytes32 r,
//         bytes32 s
//     ) internal pure returns (address, RecoverError, bytes32) {
//         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
//         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
//         // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most
//         // signatures from current libraries generate a unique signature with an s-value in the lower half order.
//         //
//         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
//         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
//         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
//         // these malleable signatures as well.
//         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
//             return (address(0), RecoverError.InvalidSignatureS, s);
//         }

//         // If the signature is valid (and not malleable), return the signer address
//         address signer = ecrecover(hash, v, r, s);
//         if (signer == address(0)) {
//             return (address(0), RecoverError.InvalidSignature, bytes32(0));
//         }

//         return (signer, RecoverError.NoError, bytes32(0));
//     }

//     /**
//      * @dev Overload of {ECDSA-recover} that receives the `v`,
//      * `r` and `s` signature fields separately.
//      */
//     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
//         (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);
//         _throwError(error, errorArg);
//         return recovered;
//     }

//     /**
//      * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.
//      */
//     function _throwError(RecoverError error, bytes32 errorArg) private pure {
//         if (error == RecoverError.NoError) {
//             return; // no error: do nothing
//         } else if (error == RecoverError.InvalidSignature) {
//             revert ECDSAInvalidSignature();
//         } else if (error == RecoverError.InvalidSignatureLength) {
//             revert ECDSAInvalidSignatureLength(uint256(errorArg));
//         } else if (error == RecoverError.InvalidSignatureS) {
//             revert ECDSAInvalidSignatureS(errorArg);
//         }
//     }
// }


// // File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)

// pragma solidity ^0.8.20;






// /**
//  * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
//  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
//  *
//  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
//  * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't
//  * need to send a transaction, and thus is not required to hold Ether at all.
//  */
// abstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {
//     bytes32 private constant PERMIT_TYPEHASH =
//         keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");

//     /**
//      * @dev Permit deadline has expired.
//      */
//     error ERC2612ExpiredSignature(uint256 deadline);

//     /**
//      * @dev Mismatched signature.
//      */
//     error ERC2612InvalidSigner(address signer, address owner);

//     /**
//      * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `"1"`.
//      *
//      * It's a good idea to use the same `name` that is defined as the ERC20 token name.
//      */
//     function __ERC20Permit_init(string memory name) internal onlyInitializing {
//         __EIP712_init_unchained(name, "1");
//     }

//     function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}

//     /**
//      * @inheritdoc IERC20Permit
//      */
//     function permit(
//         address owner,
//         address spender,
//         uint256 value,
//         uint256 deadline,
//         uint8 v,
//         bytes32 r,
//         bytes32 s
//     ) public virtual {
//         if (block.timestamp > deadline) {
//             revert ERC2612ExpiredSignature(deadline);
//         }

//         bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));

//         bytes32 hash = _hashTypedDataV4(structHash);

//         address signer = ECDSA.recover(hash, v, r, s);
//         if (signer != owner) {
//             revert ERC2612InvalidSigner(signer, owner);
//         }

//         _approve(owner, spender, value);
//     }

//     /**
//      * @inheritdoc IERC20Permit
//      */
//     function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {
//         return super.nonces(owner);
//     }

//     /**
//      * @inheritdoc IERC20Permit
//      */
//     // solhint-disable-next-line func-name-mixedcase
//     function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {
//         return _domainSeparatorV4();
//     }
// }


// // File @openzeppelin/contracts/interfaces/IERC1271.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)

// pragma solidity ^0.8.20;

// /**
//  * @dev Interface of the ERC1271 standard signature validation method for
//  * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].
//  */
// interface IERC1271 {
//     /**
//      * @dev Should return whether the signature provided is valid for the provided data
//      * @param hash      Hash of the data to be signed
//      * @param signature Signature byte array associated with _data
//      */
//     function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);
// }


// // File @openzeppelin/contracts/utils/cryptography/SignatureChecker.sol@v5.0.2

// // Original license: SPDX_License_Identifier: MIT
// // OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)

// pragma solidity ^0.8.20;


// /**
//  * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA
//  * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like
//  * Argent and Safe Wallet (previously Gnosis Safe).
//  */
// library SignatureChecker {
//     /**
//      * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the
//      * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.
//      *
//      * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
//      * change through time. It could return true at block N and false at block N+1 (or the opposite).
//      */
//     function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {
//         (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);
//         return
//             (error == ECDSA.RecoverError.NoError && recovered == signer) ||
//             isValidERC1271SignatureNow(signer, hash, signature);
//     }

//     /**
//      * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated
//      * against the signer smart contract using ERC1271.
//      *
//      * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
//      * change through time. It could return true at block N and false at block N+1 (or the opposite).
//      */
//     function isValidERC1271SignatureNow(
//         address signer,
//         bytes32 hash,
//         bytes memory signature
//     ) internal view returns (bool) {
//         (bool success, bytes memory result) = signer.staticcall(
//             abi.encodeCall(IERC1271.isValidSignature, (hash, signature))
//         );
//         return (success &&
//             result.length >= 32 &&
//             abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));
//     }
// }


// // File contracts/AccessManager.sol

// // Original license: SPDX_License_Identifier: MIT

// pragma solidity ^0.8.26;

// abstract contract AccessManager {
//     // bytes32 public constant OWNER_ROLE = keccak256("OWNER_ROLE");

//     bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

//     // bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE"); //L2 only

//     bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

//     bytes32 public constant BLACKLISTER_MANAGER_ROLE = keccak256("BLACKLISTER_MANAGER_ROLE");
//     bytes32 public constant BLACKLISTER_ROLE = keccak256("BLACKLISTER_ROLE");

//     bytes32 public constant WHITELISTER_MANAGER_ROLE = keccak256("WHITELISTER_MANAGER_ROLE");
//     bytes32 public constant WHITELISTER_ROLE = keccak256("WHITELISTER_ROLE");

//     bytes32 public constant MASTER_MINTER_ROLE = keccak256("MASTER_MINTER_ROLE");
//     bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

//     bytes32 public constant FEE_MANAGER_ROLE = keccak256("FEE_MANAGER_ROLE");
//     bytes32 public constant FEE_HOLDER_ROLE = keccak256("FEE_HOLDER_ROLE");

//     function _accessHasRole(bytes32 role, address account) internal view virtual returns (bool);
// }


// // File contracts/Blacklistable.sol

// // Original license: SPDX_License_Identifier: MIT

// pragma solidity ^0.8.26;

// /**
//  * @title Blacklistable Token
//  * @dev Allows accounts to be blacklisted by a "blacklister" role
//  */
// abstract contract Blacklistable is AccessManager {
//     event Blacklisted(address indexed _account);
//     event UnBlacklisted(address indexed _account);
//     event BlacklisterChanged(address indexed newBlacklister);

//     /**
//      * @dev Throws if called by any account other than the blacklister.
//      */
//     modifier onlyBlacklister() {
//         _checkOnlyBlacklister();
//         _;
//     }

//     /**
//      * @dev Throws if argument account is blacklisted.
//      * @param _account The address to check.
//      */
//     modifier notBlacklisted(address _account) {
//         require(!_isBlacklisted(_account), "Blacklistable: account is blacklisted");
//         _;
//     }

//     function _checkOnlyBlacklister() internal view virtual {
//         require(_accessHasRole(BLACKLISTER_MANAGER_ROLE, msg.sender), "Blacklistable: caller is not the blacklister");
//     }

//     /**
//      * @notice Checks if account is blacklisted.
//      * @param _account The address to check.
//      * @return True if the account is blacklisted, false if the account is not blacklisted.
//      */
//     function isBlacklisted(address _account) external view returns (bool) {
//         return _isBlacklisted(_account);
//     }

//     /**
//      * @notice Adds account to blacklist.
//      * @param _account The address to blacklist.
//      */
//     function blacklist(address _account) external onlyBlacklister {
//         _blacklist(_account);
//         emit Blacklisted(_account);
//     }

//     /**
//      * @notice Adds account to batchBlacklist.
//      * @param _account The list of addresses to blacklist.
//      */
//     function batchBlacklist(address[] calldata _account) external onlyBlacklister {
//         require(_account.length >= 1, "_account and amounts length mismatch");
//         for (uint256 i = 0; i < _account.length; i++) {
//             _blacklist(_account[i]);
//         }
//     }

//     /**
//      * @notice Removes account from blacklist.
//      * @param _account The address to remove from the blacklist.
//      */
//     function unBlacklist(address _account) external onlyBlacklister {
//         _unBlacklist(_account);
//         emit UnBlacklisted(_account);
//     }

//     /**
//      * @notice Updates the blacklister address.
//      * @param _newBlacklister The address of the new blacklister.
//      */
//     function updateBlacklister(address _newBlacklister) external virtual;

//     /**
//      * @dev Checks if account is blacklisted.
//      * @param _account The address to check.
//      * @return true if the account is blacklisted, false otherwise.
//      */
//     function _isBlacklisted(address _account) internal view virtual returns (bool);

//     /**
//      * @dev Helper method that blacklists an account.
//      * @param _account The address to blacklist.
//      */
//     function _blacklist(address _account) internal virtual;

//     /**
//      * @dev Helper method that unblacklists an account.
//      * @param _account The address to unblacklist.
//      */
//     function _unBlacklist(address _account) internal virtual;
// }


// // File contracts/interfaces/FeeV1Interface.sol

// // Original license: SPDX_License_Identifier: MIT

// pragma solidity ^0.8.26;

// interface FeeV1Interface {
//     event Params(address _feeAccount, uint256 feeBasisPoints, uint256 maxFee);

//     function calcCommonFee(uint256 _value) external view returns (uint256);

//     function commonFeeAccount() external view returns (address);

//     function totalFee(address _account) external view returns (uint256);
// }


// // File contracts/interfaces/TokenErrors.sol

// // Original license: SPDX_License_Identifier: MIT

// pragma solidity ^0.8.26;

// interface TokenErrors {
//     error SubtractionOverflow();
//     error DivisionOverflow();
//     error MultiplicationOverflow();
//     event ApprovalMint(address indexed spender, uint256 value);
//     error InvalidSpender(address spender);
//     error InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
// }


// // File contracts/interfaces/FeeAggregator.sol

// // Original license: SPDX_License_Identifier: MIT

// pragma solidity ^0.8.26;



// abstract contract FeeAggregator is FeeV1Interface, TokenErrors {
//     using Math for uint256;

//     uint256 public basisPointsRate;
//     uint256 constant basisPointsRateDecimal = 1000;
//     address public feeAccount;
//     uint256 public maximumFee;
//     uint256 constant MAX_SETTABLE_BASIS_POINTS = 20;
//     uint256 constant MAX_SETTABLE_FEE = 5000 * 1e2;

//     uint256 public constant MAX_UINT = 2 ** 256 - 1;

//     mapping(address => uint256) public feeAccounts;

//     mapping(address => uint256) public feeRateAccounts;

//     address[] public feeAccountKeys;

//     modifier onlyFeeManager() {
//         _checkOnlyFeeManager();
//         _;
//     }

//     function _checkOnlyFeeManager() internal view virtual;

//     function _addFeeAccount(address account, uint256 amount, uint256 newBasisPoints) internal {
//         feeAccounts[account] = amount;

//         feeRateAccounts[account] = newBasisPoints;
//         if (!contains(account)) {
//             feeAccountKeys.push(account);
//         }
//     }

//     function contains(address account) internal view returns (bool) {
//         for (uint256 i = 0; i < feeAccountKeys.length; i++) {
//             if (feeAccountKeys[i] == account) {
//                 return true;
//             }
//         }
//         return false;
//     }

//     function updateFeeManager(address account) external virtual;

//     function _updateFeeAccountAmount(address account, uint256 amount) internal returns (bool) {
//         uint256 oldAmount = feeAccounts[account];
//         uint256 newAmount = oldAmount + amount;
//         feeAccounts[account] = newAmount;

//         return true;
//     }

//     function _removeFeeAccount(address account) internal onlyFeeManager returns (bool) {
//         delete feeAccounts[account];
//         for (uint256 i = 0; i < feeAccountKeys.length; i++) {
//             if (feeAccountKeys[i] == account) {
//                 delete feeAccountKeys[i];
//                 break;
//             }
//         }

//         return true;
//     }

//     function getFeeAccounts() external view returns (address[] memory) {
//         return feeAccountKeys;
//     }

//     function _setCommonParam(
//         address _feeAccount,
//         uint256 newBasisPoints,
//         uint256 newMaxFee,
//         uint8 _decimals
//     ) internal returns (bool) {
//         feeAccount = _feeAccount;
//         basisPointsRate = newBasisPoints;
//         (bool flag, uint256 fee) = newMaxFee.tryMul(uint256(10) ** _decimals);
//         if (!flag) {
//             revert MultiplicationOverflow();
//         }

//         maximumFee = fee;
//         emit Params(feeAccount, basisPointsRate, maximumFee);
//         return true;
//     }

//     /**
//      * @notice Adds account to blacklist.
//      * @param _account The address to blacklist.
//      */
//     function totalFee(address _account) public view override returns (uint256) {
//         require(_account != address(0), "FeeAggregator: _account is the zero address");
//         return feeAccounts[_account];
//     }

//     function calcCommonFee(uint256 _value) public view override returns (uint256) {
//         (bool basicFlag, uint256 basicFee) = _value.tryMul(basisPointsRate);
//         if (!basicFlag) {
//             revert MultiplicationOverflow();
//         }

//         (bool flag, uint256 fee) = basicFee.tryDiv(basisPointsRateDecimal);
//         if (!flag) {
//             revert DivisionOverflow();
//         }

//         if (fee > maximumFee) {
//             fee = maximumFee;
//         }
//         return fee;
//     }

//     function commonFeeAccount() public view override returns (address) {
//         return feeAccount;
//     }

//     function _calcFee(address account, uint256 _value) internal view returns (uint256 _fee) {
//         uint256 accountPointsRate = feeRateAccounts[account];
//         if (accountPointsRate <= 0) {
//             return uint256(0);
//         }

//         (bool basicFlag, uint256 basicFee) = _value.tryMul(accountPointsRate);
//         if (!basicFlag) {
//             revert MultiplicationOverflow();
//         }

//         (bool flag, uint256 fee) = basicFee.tryDiv(basisPointsRateDecimal);
//         if (!flag) {
//             revert DivisionOverflow();
//         }

//         if (fee > maximumFee) {
//             fee = maximumFee;
//         }

//         return fee;
//     }
// }


// // File contracts/Minterable.sol

// // Original license: SPDX_License_Identifier: MIT

// pragma solidity ^0.8.26;


// abstract contract Minterable is AccessManager, TokenErrors {
//     mapping(address spender => uint256) _allowances;

//     event MinterConfigured(address indexed minter, uint256 amount);
//     event MinterRemoved(address indexed oldMinter);
//     event MasterMinterChanged(address indexed newMasterMinter);

//     modifier onlyMinters() {
//         require(_accessHasRole(MINTER_ROLE, msg.sender), "Minterable: caller is not a minter");
//         _;
//     }

//     modifier onlyMasterMinter() {
//         require(_accessHasRole(MASTER_MINTER_ROLE, msg.sender), "Minterable: caller is not the masterMinter");
//         _;
//     }

//     function isMinter(address account) external view returns (bool) {
//         return _accessHasRole(MINTER_ROLE, account);
//     }

//     function addMinter(address minter, uint256 amount) external virtual returns (bool);

//     function removeMinter(address minter) external virtual returns (bool);

//     function updateMasterMinter(address _newMasterMinter) public virtual;

//     function _approveMint(address spender, uint256 value) internal {
//         _approveMint(spender, value, true);
//     }

//     function _approveMint(address spender, uint256 value, bool emitEvent) internal virtual {
//         if (spender == address(0)) {
//             revert InvalidSpender(address(0));
//         }

//         _allowances[spender] = value;
//         if (emitEvent) {
//             emit ApprovalMint(spender, value);
//         }
//     }

//     function _spendAllowanceMint(address spender, uint256 value) internal virtual {
//         uint256 currentAllowance = _allowances[spender];
//         if (currentAllowance != type(uint256).max) {
//             if (currentAllowance < value) {
//                 revert InsufficientAllowance(spender, currentAllowance, value);
//             }
//             unchecked {
//                 _approveMint(spender, currentAllowance - value, false);
//             }
//         }
//     }
// }


// // File contracts/TokenBaseUpgradeable.sol

// // Original license: SPDX_License_Identifier: MIT

// pragma solidity ^0.8.26;








// contract TokenBaseUpgradeable is
//     ERC20PausableUpgradeable,
//     OwnableUpgradeable,
//     ERC20PermitUpgradeable,
//     AccessControlUpgradeable,
//     Blacklistable,
//     Minterable,
//     FeeAggregator
// {
//     event Mint(address indexed minter, address indexed to, uint256 amount);
//     event Burn(address indexed burner, uint256 amount);

//     uint8 internal _decimals;

//     // 初始化函数，替代构造函数
//     function initialize(
//         address initialOwner,
//         string memory name_,
//         string memory symbol_,
//         uint8 decimals_
//     ) public initializer {
//         __ERC20_init(name_, symbol_); // 初始化 ERC20 代币
//         __ERC20Permit_init(name_); // 初始化 ERC20Permit
//         __ERC20Pausable_init(); // 初始化可暂停功能
//         __Ownable_init(initialOwner); // 初始化所有权管理

//         __AccessControl_init(); // 初始化访问权限管理

//         _decimals = decimals_; //设置精度

//         _grantRole(DEFAULT_ADMIN_ROLE, initialOwner);
//         _grantRole(ADMIN_ROLE, initialOwner);
//     }

//     function setRoleAdmin(bytes32 role, bytes32 admin) public virtual onlyOwner {
//         _setRoleAdmin(role, admin);
//     }

//     function _accessHasRole(bytes32 role, address account) internal view virtual override returns (bool) {
//         return super.hasRole(role, account);
//     }

//     function decimals() public view virtual override returns (uint8) {
//         return _decimals;
//     }

//     function burnFrom(address account, uint256 value) internal virtual whenNotPaused {
//         //        super._spendAllowance(account, _msgSender(), value);
//         super._burn(account, value);
//     }

//     function transfer(address to, uint256 amount) public virtual override whenNotPaused returns (bool) {
//         super.transfer(to, amount);
//         return true;
//     }

//     function transferFrom(
//         address from,
//         address to,
//         uint256 amount
//     )
//         public
//         virtual
//         override
//         whenNotPaused
//         notBlacklisted(_msgSender())
//         notBlacklisted(from)
//         notBlacklisted(to)
//         returns (
//             // isAddressWhitelisted(_msgSender())
//             // isAddressWhitelisted(from)
//             // isAddressWhitelisted(to)
//             bool
//         )
//     {
//         // layer2 implementation

//         // require(
//         //     hasRole(OPERATOR_ROLE, _msgSender()),
//         //     "TokenBaseUpgradeable: must have OPERATOR_ROLE role to operation"
//         // );
//         // super.transferFrom(from, to, amount);
//         return true;
//     }

//     function pause() public whenNotPaused {
//         require(hasRole(PAUSER_ROLE, _msgSender()), "TokenBaseUpgradeable: must have pauser role to pause");
//         super._pause();
//     }

//     function unpause() public whenPaused {
//         require(hasRole(PAUSER_ROLE, _msgSender()), "TokenBaseUpgradeable: must have pauser role to unpause");
//         super._unpause();
//     }

//     function _update(
//         address from,
//         address to,
//         uint256 value
//     ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {
//         super._update(from, to, value);
//     }

//     function approve(
//         address spender,
//         uint256 value
//     )
//         public
//         virtual
//         override
//         whenNotPaused
//         notBlacklisted(_msgSender())
//         notBlacklisted(spender)
//         returns (
//             // notBlacklisted(from)
//             // notBlacklisted(to)
//             // isAddressWhitelisted(_msgSender())
//             // isAddressWhitelisted(from)
//             // isAddressWhitelisted(to)
//             bool
//         )
//     {
//         super.approve(spender, value);
//         return true;
//     }

//     /**
//      * The ’owner‘ lets ‘spender’ spend its Mintable amount
//      */
//     function approveMint(
//         address minter,
//         uint256 amount
//     ) external virtual whenNotPaused onlyMasterMinter returns (bool) {
//         super._checkRole(MINTER_ROLE, minter);
//         super._approveMint(minter, amount);
//         return true;
//     }

//     function addMinter(
//         address minter,
//         uint256 amount
//     ) external virtual override whenNotPaused onlyMasterMinter returns (bool) {
//         super._grantRole(MINTER_ROLE, minter);
//         super._approveMint(minter, amount);
//         emit MinterConfigured(minter, amount);
//         return true;
//     }

//     function removeMinter(address minter) external override onlyMasterMinter returns (bool) {
//         super._revokeRole(MINTER_ROLE, minter);
//         emit MinterRemoved(minter);
//         return true;
//     }

//     function updateMasterMinter(address _newMasterMinter) public virtual override onlyOwner {
//         require(_newMasterMinter != address(0), "TokenBaseUpgradeable: new masterMinter is the zero address");
//         // TODO
//         //        require(getRoleAdmin(MASTER_MINTER_ROLE) == address(0), "TokenBaseUpgradeable: new masterMinter member zero address");
//         _grantRole(MASTER_MINTER_ROLE, _newMasterMinter);
//         emit MasterMinterChanged(_newMasterMinter);
//     }

//     function updateBlacklister(address _newBlacklister) public override onlyOwner {
//         require(_newBlacklister != address(0), "TokenBaseUpgradeable: new blacklister is the zero address");
//         // TODO
//         //        require(getRoleAdmin(MASTER_MINTER_ROLE) == address(0), "TokenBaseUpgradeable: new blacklister member zero address");
//         super._grantRole(BLACKLISTER_MANAGER_ROLE, _newBlacklister);
//         emit BlacklisterChanged(_newBlacklister);
//     }

//     function _blacklist(address _account) internal override {
//         super._grantRole(BLACKLISTER_ROLE, _account);
//     }

//     function _unBlacklist(address _account) internal override {
//         super._revokeRole(BLACKLISTER_ROLE, _account);
//     }

//     function _isBlacklisted(address _account) internal view override returns (bool) {
//         return super.hasRole(BLACKLISTER_ROLE, _account);
//     }

//     function addFeeAccount(address account) public onlyFeeManager returns (bool) {
//         super._grantRole(FEE_HOLDER_ROLE, account);
//         _addFeeAccount(account, 0, 0);
//         return true;
//     }
//     function removeFeeAccount(address account) public onlyFeeManager returns (bool) {
//         // _checkOnlyFeeHolder(account);
//         super._checkRole(FEE_HOLDER_ROLE, account);
//         super._removeFeeAccount(account);
//         super._revokeRole(BLACKLISTER_ROLE, account);
//         return true;
//     }

//     /**
//      * @notice setParams the JDSC token contract.
//      * @param newBasisPoints       the token fee ratio.
//      * @param newMaxFee     the token handling fees.
//      */
//     function setParams(
//         address _feeAccount,
//         uint256 newBasisPoints,
//         uint256 newMaxFee,
//         uint8 rateDecimals
//     ) public onlyFeeManager returns (bool) {
//         require(_feeAccount != address(0));
//         super._checkRole(FEE_HOLDER_ROLE, _feeAccount);
//         require(newBasisPoints < MAX_SETTABLE_BASIS_POINTS);
//         require(newMaxFee < MAX_SETTABLE_FEE);

//         super._setCommonParam(_feeAccount, newBasisPoints, newMaxFee, rateDecimals);
//         super._addFeeAccount(_feeAccount, 0, basisPointsRate);

//         return true;
//     }

//     function calcFee(address account, uint256 _value) public view returns (uint256 _fee) {
//         super._checkRole(FEE_HOLDER_ROLE, account);
//         return super._calcFee(account, _value);
//     }

//     function updateFeeManager(address account) external virtual override onlyOwner {
//         require(account != address(0), "TokenBaseUpgradeable: new fee manager is the zero address");
//         super._grantRole(FEE_MANAGER_ROLE, account);
//     }

//     function _checkOnlyFeeManager() internal view virtual override {
//         require(_accessHasRole(FEE_MANAGER_ROLE, msg.sender), "FeeAggregator: caller is not the feeManager");
//     }
// }


// // File contracts/Whitelistable.sol

// // Original license: SPDX_License_Identifier: MIT

// pragma solidity ^0.8.26;

// /**
//  * @title Whitelistable Token
//  * @dev Allows accounts to be whitelisted by a "whitelister" role
//  */
// abstract contract Whitelistable is AccessManager {
//     event Whitelisted(address indexed _account);
//     event UnWhitelisted(address indexed _account);
//     event WhitelisterChanged(address indexed newWhitelister);

//     /**
//      * @dev Throws if called by any account other than the whitelister.
//      */
//     modifier onlyWhitelister() {
//         _checkOnlyWhitelister();
//         _;
//     }

//     /**
//      * @dev Throws if argument account is whitelister.
//      * @param _account The address to check.
//      */
//     modifier notWhitelisted(address _account) {
//         if (_whitestatus()) {
//             require(!_isWhitelisted(_account), "Whitelistable: account is whitelisted");
//         }
//         _;
//     }

//     /**
//      * @dev Throws if argument account is whitelister.
//      * @param _account The address to check.
//      */
//     modifier isAddressWhitelisted(address _account) {
//         if (_whitestatus()) {
//             require(_isWhitelisted(_account), "Whitelistable: account is not the whitelisted");
//         }

//         _;
//     }

//     function _checkOnlyWhitelister() internal view virtual {
//         require(_accessHasRole(WHITELISTER_MANAGER_ROLE, msg.sender), "Whitelistable: caller is not the whitelister");
//     }

//     /**
//      * @notice Checks if account is whitelisted.
//      * @param _account The address to check.
//      * @return True if the account is whitelisted, false if the account is not whitelisted.
//      */
//     function isWhitelisted(address _account) external view returns (bool) {
//         return _isWhitelisted(_account);
//     }

//     /**
//      * @notice Adds account to whitelist.
//      * @param _account The address to whitelist.
//      */
//     function whitelist(address _account) external onlyWhitelister {
//         _whitelist(_account);
//         emit Whitelisted(_account);
//     }

//     /**
//      * @notice Adds account to batchWhitelist.
//      * @param _account  The list of address to whitelist.
//      */
//     function batchWhitelist(address[] calldata _account) external onlyWhitelister {
//         require(_account.length >= 1, "_account and amounts length mismatch");
//         for (uint256 i = 0; i < _account.length; i++) {
//             _whitelist(_account[i]);
//         }
//     }

//     /**
//      * @notice Removes account from whitelist.
//      * @param _account The address to remove from the whitelist.
//      */
//     function unWhitelist(address _account) external onlyWhitelister {
//         _unWhitelist(_account);
//         emit UnWhitelisted(_account);
//     }

//     /**
//      * @notice Updates the whitelister address.
//      * @param _newWhitelister The address of the new whitelister.
//      */
//     function updateWhitelister(address _newWhitelister) external virtual;

//     /**
//      * @dev Checks if account is whitelisted.
//      * @param _account The address to check.
//      * @return true if the account is whitelisted, false otherwise.
//      */
//     function _isWhitelisted(address _account) internal view virtual returns (bool);

//     /**
//      * @dev Helper method that whitelists an account.
//      * @param _account The address to whitelist.
//      */
//     function _whitelist(address _account) internal virtual;

//     /**
//      * @dev Helper method that unwhitelists an account.
//      * @param _account The address to unwhitelist.
//      */
//     function _unWhitelist(address _account) internal virtual;

//     function _whitestatus() internal view virtual returns (bool);
// }


// // File contracts/TokenUpgradeable.sol

// // Original license: SPDX_License_Identifier: MIT

// pragma solidity ^0.8.26;



// // import {TokenErrors} from "./interfaces/TokenErrors.sol";

// contract TokenUpgradeable is TokenBaseUpgradeable, Whitelistable {
//     using Math for uint256;

//     bool public whitestatus;

//     function updateWhitelister(address _newWhitelister) external override onlyOwner {
//         require(_newWhitelister != address(0), "TokenUpgradeable: new whitelister is the zero address");
//         // TODO
//         super._grantRole(WHITELISTER_MANAGER_ROLE, _newWhitelister);
//         emit WhitelisterChanged(_newWhitelister);
//     }

//     function _isWhitelisted(address _account) internal view override returns (bool) {
//         return super.hasRole(WHITELISTER_ROLE, _account);
//     }

//     function _whitelist(address _account) internal override {
//         super._grantRole(WHITELISTER_ROLE, _account);
//     }

//     function _unWhitelist(address _account) internal override {
//         super._revokeRole(WHITELISTER_ROLE, _account);
//     }

//     function _whitestatus() internal view override returns (bool) {
//         return whitestatus;
//     }

//     function updateWhitestatus(bool status) external onlyWhitelister returns (bool) {
//         whitestatus = status;
//         return true;
//     }

//     function mint(
//         address to,
//         uint256 amount
//     )
//         public
//         whenNotPaused
//         notBlacklisted(_msgSender())
//         notBlacklisted(to)
//         isAddressWhitelisted(_msgSender())
//         isAddressWhitelisted(to)
//     {
//         if (to != owner()) {
//             _checkRole(MINTER_ROLE, _msgSender());
//             _spendAllowanceMint(_msgSender(), amount);
//         }

//         super._mint(to, amount);
//     }

//     function transfer(
//         address to,
//         uint256 amount
//     )
//         public
//         virtual
//         override
//         whenNotPaused
//         notBlacklisted(msg.sender)
//         notBlacklisted(to)
//         isAddressWhitelisted(msg.sender)
//         isAddressWhitelisted(to)
//         returns (bool)
//     {
//         uint256 fee = calcCommonFee(amount);
//         (bool flag, uint256 sendAmount) = amount.trySub(fee);
//         if (!flag) {
//             revert SubtractionOverflow();
//         }

//         if (fee > 0) {
//             address feeAccount = commonFeeAccount();
//             super._transfer(msg.sender, feeAccount, fee);
//         }

//         super._transfer(msg.sender, to, sendAmount);

//         return true;
//     }

//     function redeem(
//         address account,
//         address feeAccount,
//         uint256 amount,
//         uint256 validAfter,
//         uint8 v,
//         bytes32 r,
//         bytes32 s
//     )
//         external
//         whenNotPaused
//         notBlacklisted(account)
//         notBlacklisted(feeAccount)
//         isAddressWhitelisted(account)
//         isAddressWhitelisted(feeAccount)
//     {
//         _checkRole(MINTER_ROLE, _msgSender());
//         super.permit(account, _msgSender(), amount, validAfter, v, r, s);

//         _checkRole(FEE_HOLDER_ROLE, feeAccount);
//         uint256 fee = calcFee(feeAccount, amount);
//         (bool flag, uint256 sendAmount) = amount.trySub(fee);
//         if (!flag) {
//             revert SubtractionOverflow();
//         }

//         _spendAllowance(account, _msgSender(), amount);
//         if (fee > 0) {
//             //            _spendAllowance(account, _msgSender(), fee);
//             super._transfer(account, feeAccount, fee);
//             _updateFeeAccountAmount(feeAccount, fee);
//         }

//         super._burn(account, sendAmount);
//         //        super.burnFrom(account, sendAmount);
//     }
// }
